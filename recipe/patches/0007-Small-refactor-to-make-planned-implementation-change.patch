From 36af3230e049f8cc70f43e57065c2a73d6f159c2 Mon Sep 17 00:00:00 2001
From: Gregory Thornton <gregthornton@google.com>
Date: Wed, 23 Jun 2021 08:12:43 -0700
Subject: [PATCH 07/20] Small refactor to make planned implementation changes
 easier.

PiperOrigin-RevId: 381034028
---
 tree/BUILD        |  11 ++++-
 tree/__init__.py  |  80 +++----------------------------------
 tree/sequence.py  | 100 ++++++++++++++++++++++++++++++++++++++++++++++
 tree/tree.cc      |  42 ++++++-------------
 tree/tree.h       |  21 ++++++++++
 tree/tree_test.py |   5 +++
 6 files changed, 154 insertions(+), 105 deletions(-)
 create mode 100644 tree/sequence.py

diff --git a/tree/BUILD b/tree/BUILD
index 5a9a47f..0a533d9 100644
--- a/tree/BUILD
+++ b/tree/BUILD
@@ -1,6 +1,6 @@
 # Description:
 #   Tree provides utilities for working with nested data structures.
-
+# load_pybind_extension
 load(
     "//tree:build_defs.bzl",
     "COMPAT_USERS",
@@ -21,6 +21,8 @@ py_library(
     visibility = ["//visibility:public"],
     deps = [
         ":_tree",  # build_cleaner:keep
+        ":experimental",
+        ":sequence",
     ],
 )
 
@@ -42,6 +44,13 @@ tree_py_extension(
     ],
 )
 
+py_library(
+    name = "sequence",
+    srcs = ["sequence.py"],
+    srcs_version = "PY2AND3",
+    deps = [":_tree"],
+)
+
 tree_py_test(
     name = "tree_test",
     srcs = ["tree_test.py"],
diff --git a/tree/__init__.py b/tree/__init__.py
index 718f6ee..c49d066 100644
--- a/tree/__init__.py
+++ b/tree/__init__.py
@@ -21,6 +21,10 @@ import functools
 import logging
 import sys
 import types
+from tree.sequence import _is_attrs
+from tree.sequence import _is_namedtuple
+from tree.sequence import _sequence_like
+from tree.sequence import _sorted
 
 # pylint: disable=g-import-not-at-top
 try:
@@ -131,79 +135,6 @@ def _get_attrs_items(obj):
           for attr in obj.__class__.__attrs_attrs__]
 
 
-def _sorted(dictionary):
-  """Returns a sorted list of the dict keys, with error if keys not sortable."""
-  try:
-    return sorted(dictionary)
-  except TypeError:
-    raise TypeError("tree only supports dicts with sortable keys.")
-
-
-def _is_attrs(instance):
-  return _tree.is_attrs(instance)
-
-
-def _is_namedtuple(instance, strict=False):
-  """Returns True iff `instance` is a `namedtuple`.
-
-  Args:
-    instance: An instance of a Python object.
-    strict: If True, `instance` is considered to be a `namedtuple` only if
-        it is a "plain" namedtuple. For instance, a class inheriting
-        from a `namedtuple` will be considered to be a `namedtuple`
-        iff `strict=False`.
-
-  Returns:
-    True if `instance` is a `namedtuple`.
-  """
-  return _tree.is_namedtuple(instance, strict)
-
-
-def _sequence_like(instance, args):
-  """Converts the sequence `args` to the same type as `instance`.
-
-  Args:
-    instance: an instance of `tuple`, `list`, `namedtuple`, `dict`, or
-        `collections.OrderedDict`.
-    args: elements to be converted to the `instance` type.
-
-  Returns:
-    `args` with the type of `instance`.
-  """
-  if isinstance(instance, (dict, collections_abc.Mapping)):
-    # Pack dictionaries in a deterministic order by sorting the keys.
-    # Notice this means that we ignore the original order of `OrderedDict`
-    # instances. This is intentional, to avoid potential bugs caused by mixing
-    # ordered and plain dicts (e.g., flattening a dict but using a
-    # corresponding `OrderedDict` to pack it back).
-    result = dict(zip(_sorted(instance), args))
-    keys_and_values = ((key, result[key]) for key in instance)
-    if isinstance(instance, collections.defaultdict):
-      # `defaultdict` requires a default factory as the first argument.
-      return type(instance)(instance.default_factory, keys_and_values)
-    elif isinstance(instance, types.MappingProxyType):
-      # MappingProxyType requires a dict to proxy to.
-      return type(instance)(dict(keys_and_values))
-    else:
-      return type(instance)(keys_and_values)
-  elif isinstance(instance, collections_abc.MappingView):
-    # We can't directly construct mapping views, so we create a list instead
-    return list(args)
-  elif _is_namedtuple(instance) or _is_attrs(instance):
-    if isinstance(instance, ObjectProxy):
-      instance_type = type(instance.__wrapped__)
-    else:
-      instance_type = type(instance)
-    return instance_type(*args)
-  elif isinstance(instance, ObjectProxy):
-    # For object proxies, first create the underlying type and then re-wrap it
-    # in the proxy type.
-    return type(instance)(_sequence_like(instance.__wrapped__, args))
-  else:
-    # Not a namedtuple
-    return type(instance)(args)
-
-
 def _yield_value(iterable):
   for _, v in _yield_sorted_items(iterable):
     yield v
@@ -506,7 +437,6 @@ def map_structure(func, *structures, **kwargs):  # pylint: disable=redefined-bui
 
   for other in structures[1:]:
     assert_same_structure(structures[0], other, check_types=check_types)
-
   return unflatten_as(structures[0],
                       [func(*args) for args in zip(*map(flatten, structures))])
 
@@ -1008,3 +938,5 @@ def traverse_with_path(fn, structure, top_down=True):
         return ret
 
   return traverse_impl((), structure)
+
+
diff --git a/tree/sequence.py b/tree/sequence.py
new file mode 100644
index 0000000..f4fe942
--- /dev/null
+++ b/tree/sequence.py
@@ -0,0 +1,100 @@
+# Copyright 2019 DeepMind Technologies Limited. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ==============================================================================
+"""Contains _sequence_like and helpers for sequence data structures."""
+import collections
+from collections import abc as collections_abc
+import types
+from tree import _tree
+
+# pylint: disable=g-import-not-at-top
+try:
+  import wrapt
+  ObjectProxy = wrapt.ObjectProxy
+except ImportError:
+  class ObjectProxy(object):
+    """Stub-class for `wrapt.ObjectProxy``."""
+
+
+def _sorted(dictionary):
+  """Returns a sorted list of the dict keys, with error if keys not sortable."""
+  try:
+    return sorted(dictionary)
+  except TypeError:
+    raise TypeError("tree only supports dicts with sortable keys.")
+
+
+def _is_attrs(instance):
+  return _tree.is_attrs(instance)
+
+
+def _is_namedtuple(instance, strict=False):
+  """Returns True iff `instance` is a `namedtuple`.
+
+  Args:
+    instance: An instance of a Python object.
+    strict: If True, `instance` is considered to be a `namedtuple` only if
+        it is a "plain" namedtuple. For instance, a class inheriting
+        from a `namedtuple` will be considered to be a `namedtuple`
+        iff `strict=False`.
+
+  Returns:
+    True if `instance` is a `namedtuple`.
+  """
+  return _tree.is_namedtuple(instance, strict)
+
+
+def _sequence_like(instance, args):
+  """Converts the sequence `args` to the same type as `instance`.
+
+  Args:
+    instance: an instance of `tuple`, `list`, `namedtuple`, `dict`, or
+        `collections.OrderedDict`.
+    args: elements to be converted to the `instance` type.
+
+  Returns:
+    `args` with the type of `instance`.
+  """
+  if isinstance(instance, (dict, collections_abc.Mapping)):
+    # Pack dictionaries in a deterministic order by sorting the keys.
+    # Notice this means that we ignore the original order of `OrderedDict`
+    # instances. This is intentional, to avoid potential bugs caused by mixing
+    # ordered and plain dicts (e.g., flattening a dict but using a
+    # corresponding `OrderedDict` to pack it back).
+    result = dict(zip(_sorted(instance), args))
+    keys_and_values = ((key, result[key]) for key in instance)
+    if isinstance(instance, collections.defaultdict):
+      # `defaultdict` requires a default factory as the first argument.
+      return type(instance)(instance.default_factory, keys_and_values)
+    elif isinstance(instance, types.MappingProxyType):
+      # MappingProxyType requires a dict to proxy to.
+      return type(instance)(dict(keys_and_values))
+    else:
+      return type(instance)(keys_and_values)
+  elif isinstance(instance, collections_abc.MappingView):
+    # We can't directly construct mapping views, so we create a list instead
+    return list(args)
+  elif _is_namedtuple(instance) or _is_attrs(instance):
+    if isinstance(instance, ObjectProxy):
+      instance_type = type(instance.__wrapped__)
+    else:
+      instance_type = type(instance)
+    return instance_type(*args)
+  elif isinstance(instance, ObjectProxy):
+    # For object proxies, first create the underlying type and then re-wrap it
+    # in the proxy type.
+    return type(instance)(_sequence_like(instance.__wrapped__, args))
+  else:
+    # Not a namedtuple
+    return type(instance)(args)
diff --git a/tree/tree.cc b/tree/tree.cc
index 4a4b6d4..26840da 100644
--- a/tree/tree.cc
+++ b/tree/tree.cc
@@ -40,10 +40,6 @@ namespace py = pybind11;
 namespace tree {
 namespace {
 
-struct DecrementsPyRefcount {
-  void operator()(PyObject* p) const { Py_DECREF(p); }
-};
-
 // PyObjectPtr wraps an underlying Python object and decrements the
 // reference count in the destructor.
 //
@@ -256,21 +252,6 @@ int IsSequenceHelper(PyObject* o) {
   return check_cache->CachedLookup(o);
 }
 
-// ValueIterator interface
-class ValueIterator {
- public:
-  virtual ~ValueIterator() {}
-  virtual PyObjectPtr next() = 0;
-
-  bool valid() const { return is_valid_; }
-
- protected:
-  void invalidate() { is_valid_ = false; }
-
- private:
-  bool is_valid_ = true;
-};
-
 using ValueIteratorPtr = std::unique_ptr<ValueIterator>;
 
 // Iterate through dictionaries in a deterministic order by sorting the
@@ -407,17 +388,6 @@ class AttrsValueIterator : public ValueIterator {
   PyObjectPtr iter_;
 };
 
-ValueIteratorPtr GetValueIterator(PyObject* nested) {
-  if (PyDict_Check(nested)) {
-    return absl::make_unique<DictValueIterator>(nested);
-  } else if (IsMappingHelper(nested)) {
-    return absl::make_unique<MappingValueIterator>(nested);
-  } else if (IsAttrsHelper(nested)) {
-    return absl::make_unique<AttrsValueIterator>(nested);
-  } else {
-    return absl::make_unique<SequenceValueIterator>(nested);
-  }
-}
 
 bool FlattenHelper(
     PyObject* nested, PyObject* list,
@@ -749,6 +719,18 @@ void AssertSameStructure(PyObject* o1, PyObject* o2, bool check_types) {
   }
 }
 
+ValueIteratorPtr GetValueIterator(PyObject* nested) {
+  if (PyDict_Check(nested)) {
+    return absl::make_unique<DictValueIterator>(nested);
+  } else if (IsMappingHelper(nested)) {
+    return absl::make_unique<MappingValueIterator>(nested);
+  } else if (IsAttrsHelper(nested)) {
+    return absl::make_unique<AttrsValueIterator>(nested);
+  } else {
+    return absl::make_unique<SequenceValueIterator>(nested);
+  }
+}
+
 namespace {
 
 inline py::object pyo_or_throw(PyObject* ptr) {
diff --git a/tree/tree.h b/tree/tree.h
index 5bcf895..ab3fc59 100644
--- a/tree/tree.h
+++ b/tree/tree.h
@@ -16,6 +16,7 @@ limitations under the License.
 #ifndef TREE_H_
 #define TREE_H_
 
+#include <memory>
 #include <Python.h>
 
 namespace tree {
@@ -112,6 +113,26 @@ void AssertSameStructure(PyObject* o1, PyObject* o2, bool check_types);
 //   TypeError: The nest is or contains a dict with non-sortable keys.
 PyObject* Flatten(PyObject* nested);
 
+struct DecrementsPyRefcount {
+  void operator()(PyObject* p) const { Py_DECREF(p); }
+};
+
+// ValueIterator interface
+class ValueIterator {
+ public:
+  virtual ~ValueIterator() {}
+  virtual std::unique_ptr<PyObject, DecrementsPyRefcount> next() = 0;
+
+  bool valid() const { return is_valid_; }
+
+ protected:
+  void invalidate() { is_valid_ = false; }
+
+ private:
+  bool is_valid_ = true;
+};
+
+std::unique_ptr<ValueIterator> GetValueIterator(PyObject* nested);
 }  // namespace tree
 
 #endif  // TREE_H_
diff --git a/tree/tree_test.py b/tree/tree_test.py
index 47abcca..104deb7 100644
--- a/tree/tree_test.py
+++ b/tree/tree_test.py
@@ -1066,5 +1066,10 @@ class NestTest(parameterized.TestCase):
     expected = Bar(3)
     self.assertEqual(summed, expected)
 
+  def testNoneNodeIncluded(self):
+    structure = ((1, None))
+    self.assertEqual(tree.flatten(structure), [1, None])
+
+
 if __name__ == "__main__":
   unittest.main()
-- 
2.25.1

