From fa5d7debe5a88f2865fd5e73711bcff5877b5dd6 Mon Sep 17 00:00:00 2001
From: Rishabh Kabra <rkabra@google.com>
Date: Mon, 14 Jun 2021 09:41:43 -0700
Subject: [PATCH 04/20] Change implementation of
 `map_structure_with_path_up_to`.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This implementation gives us the additional functionality to map across subtrees. Prior to this commit, the library threw an error for the following code:

```
full = {'a': np.ones(1), 'b': np.zeros(1)}
shallow = {'a': np.ones(1)}
concat_fn = lambda *args: np.concatenate(args)
tree.map_structure_up_to(shallow, concat_fn, full, shallow)
```

Note that we are providing a template (the first argument to `map_structure_up_to`) to map `concat_fn` across full and shallow. It doesnâ€™t work even if we change `full` and `shallow` to resemble each other up to the first level:

```
full = {'a': np.ones(1), 'b': {'c': np.zeros(1)}}
shallow = {'a': np.ones(1), 'b': {}}
```

This commit makes such examples work by allowing a map to be applied across an arbitrary subtree of the input structures. Significantly, it allows passing non-identical structures into `map_structure_up_to`.

PiperOrigin-RevId: 379297132
---
 tree/__init__.py  | 75 ++++++++++++++++++++---------------------------
 tree/tree_test.py | 15 +++++++++-
 2 files changed, 46 insertions(+), 44 deletions(-)

diff --git a/tree/__init__.py b/tree/__init__.py
index afffb89..718f6ee 100644
--- a/tree/__init__.py
+++ b/tree/__init__.py
@@ -18,6 +18,7 @@
 import collections
 from collections import abc as collections_abc
 import functools
+import logging
 import sys
 import types
 
@@ -583,6 +584,22 @@ def _yield_flat_up_to(shallow_tree, input_tree, path=()):
         yield (leaf_path, leaf_value)
 
 
+def _multiyield_flat_up_to(shallow_tree, *input_trees):
+  """Same as `_yield_flat_up_to`, but takes multiple input trees."""
+  zipped_iterators = zip(*[_yield_flat_up_to(shallow_tree, input_tree)
+                           for input_tree in input_trees])
+  try:
+    for paths_and_values in zipped_iterators:
+      paths, values = zip(*paths_and_values)
+      yield paths[:1] + values
+  except KeyError as e:
+    paths = locals().get("paths", ((),))
+    raise ValueError(f"Could not find key '{e.args[0]}' in some `input_trees`. "
+                     "Please ensure the structure of all `input_trees` are "
+                     "compatible with `shallow_tree`. The last valid path "
+                     f"yielded was {paths[0]}.") from e
+
+
 def _assert_shallow_structure(shallow_tree, input_tree, check_types=True):
   """Asserts that `shallow_tree` is a shallow structure of `input_tree`.
 
@@ -775,19 +792,11 @@ def map_structure_up_to(shallow_structure, func, *structures, **kwargs):
     shallow_structure: A structure with layout common to all `structures`.
     func: A callable that accepts as many arguments as there are structures.
     *structures: Arbitrarily nested structures of the same layout.
-    **kwargs: The only valid keyword argument is `check_types`. If `True`
-      (default) the types of components within the structures have
-      to be match, e.g.
-      ``tree.map_structure_up_to([None], func, [1], (1,))`` will raise
-      a `TypeError`, otherwise this is not enforced. Note that namedtuples
-      with identical name and fields are considered to be the same type.
+    **kwargs: No valid keyword arguments.
   Raises:
-    TypeError: If the layout of `shallow_structure` does not match that of
-      `input_structure`.
-    TypeError: If `check_types` is `True` and `shallow_structure` and
-      `input_structure` differ in the types of their components.
-    ValueError: If no structures were given or if a keyword argument other
-      than `check_types` is provided.
+    ValueError: If `func` is not callable or if `structures` have different
+      layout or if the layout of `shallow_structure` does not match that of
+      `structures` or if no structures were given.
 
   Returns:
     A new structure with the same layout as `shallow_structure`.
@@ -811,45 +820,25 @@ def map_structure_with_path_up_to(shallow_structure, func, *structures,
     func: A callable that accepts a path and as many arguments as there are
       structures.
     *structures: Arbitrarily nested structures of the same layout.
-    **kwargs: The only valid keyword argument is `check_types`. If `True`
-      (default) the types of components within the structures have to be match,
-      e.g. ``tree.map_structure_with_path_up_to([None], func, [1],
-      (1,))`` will raise a `TypeError`, otherwise this is not enforced. Note
-      that namedtuples with identical name and fields are considered to be the
-      same type.
+    **kwargs: No valid keyword arguments.
 
   Raises:
-    TypeError: If `func` is not callable or if `structures` have different
+    ValueError: If `func` is not callable or if `structures` have different
       layout or if the layout of `shallow_structure` does not match that of
-      `structures`.
-    TypeError: If `check_types` is `True` and `shallow_structure` and
-      `input_structure` differ in the types of their components.
-    ValueError: If no structures were given or if a keyword argument other
-      than `check_types` is provided.
+      `structures` or if no structures were given.
 
   Returns:
     Result of repeatedly applying `func`. Has the same structure layout
     as `shallow_tree`.
   """
-  if not structures:
-    raise ValueError("Cannot map over no sequences")
-
-  check_types = kwargs.pop("check_types", True)
-
-  for input_tree in structures:
-    _assert_shallow_structure(
-        shallow_structure, input_tree, check_types=check_types)
-
-  # Flatten each input separately, apply the function to corresponding elements,
-  # then repack based on the structure of the first input.
-  flat_value_lists = (
-      flatten_up_to(shallow_structure, input_tree, check_types)
-      for input_tree in structures)
-  flat_path_list = [path for path, _
-                    in _yield_flat_up_to(shallow_structure, structures[0])]
-  return unflatten_as(
-      shallow_structure,
-      [func(*args) for args in zip(flat_path_list, *flat_value_lists)])
+  if "check_types" in kwargs:
+    logging.warning("The use of `check_types` is deprecated and does not have "
+                    "any effect.")
+  del kwargs
+  results = []
+  for path_and_values in _multiyield_flat_up_to(shallow_structure, *structures):
+    results.append(func(*path_and_values))
+  return unflatten_as(shallow_structure, results)
 
 
 def flatten_with_path(structure):
diff --git a/tree/tree_test.py b/tree/tree_test.py
index c6cbccc..dfe32bd 100644
--- a/tree/tree_test.py
+++ b/tree/tree_test.py
@@ -976,7 +976,6 @@ class NestTest(parameterized.TestCase):
            error_type=ValueError),
       dict(testcase_name="Dicts", s1={"a": 1}, s2={"b": 2},
            error_type=ValueError),
-      dict(testcase_name="Mixed", s1=(1, 2), s2=[3, 4], error_type=TypeError),
       dict(testcase_name="Nested",
            s1={"a": [2, 3, 4], "b": [1, 3]},
            s2={"b": [5, 6], "a": [8, 9]},
@@ -1016,5 +1015,19 @@ class NestTest(parameterized.TestCase):
          (1, [2]), 1, [2], 2, [3, (4, 5, 6)], 3, (4, 5, 6)],
         visited)
 
+  def testMapStructureAcrossSubtrees(self):
+    shallow = {"a": 1, "b": {"c": 2}}
+    deep1 = {"a": 2, "b": {"c": 3, "d": 2}, "e": 4}
+    deep2 = {"a": 3, "b": {"c": 2, "d": 3}, "e": 1}
+    summed = tree.map_structure_up_to(
+        shallow, lambda *args: sum(args), deep1, deep2)
+    expected = {"a": 5, "b": {"c": 5}}
+    self.assertEqual(summed, expected)
+    concatenated = tree.map_structure_up_to(
+        shallow, lambda *args: args, deep1, deep2)
+    expected = {"a": (2, 3), "b": {"c": (3, 2)}}
+    self.assertEqual(concatenated, expected)
+
+
 if __name__ == "__main__":
   unittest.main()
-- 
2.25.1

